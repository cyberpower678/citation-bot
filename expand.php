<?
// $Id$

// This function, given $original_code, returns the $text with any citation templates expanded as far as possible.

function old_expand_text ($original_code,
        $commit_edits = false,
        $editing_cite_doi_template = false, //If $editing_cite_doi_template = true, certain formatting changes will be applied for consistency.
        $cite_doi_start_code = null, // $cite_doi_start_code is wikicode specified if creating a cite doi template.  (Possibly redundant now?)
        $page_title = 'unspecified'
        ) {
  global $editInitiator, $edit_summaryStart, $initiatedBy,
          $authors_missing,
          $dotEncode, $dotDecode, $pcEncode, $pcDecode, 
          $edit_summary_end, $slow_mode, $html_output;

  // TODO: if 9 authors and display_authors not set, either find more authors or set display_authors

  ############################### Finished with all citations ##############################
  #########################  code is now complete and ready for processing.   #######################
  if (trim($new_code)) {
      $edit_summary = $edit_summaryStart . $editInitiator . $auto_summary . $initiatedBy . $edit_summary_end;
      $outputText = "\n\n\n<h5>Output</h5>\n\n\n<!--New code:--><textarea rows=50>" 
      . ($html_output ? htmlentities(mb_convert_encoding($new_code, "UTF-8")) : $new_code)
      . "</textarea><!--DONE!-->\n\n\n<p><b>Bot switched off</b> &rArr; no edit made to"
              . " $page.<br><b>Changes:</b> <i>$auto_summary</i></p>";
      if ($editing_cite_doi_template && strtolower(substr(trim($new_code), 0, 2)) != "{{") {
        if (substr($new_code, 0, 15) == "HTTP/1.0 200 OK") {
          echo "Headers included in pagecode; removing...\n";
          $new_code = preg_replace("~$[\s\S]+\{\{~", "{{", $new_code);
        } else {
          /*mail ("MartinS+citewatch@gmail.com"
                , "Citewatch ERROR"
                , "Output does not begin with {{, but [" . strtolower(substr(trim($new_code), 0, 25)) . "]
                . \n\n[Page = $page]\n[SmartSum = $auto_summary ]\n[\$citation = ". print_r($citation, 1)
                . "]\n[Request variables = ".print_r($_REQUEST, 1) . "]\n [p = "
                . print_r($p,1)
                . "] \n[pagecode =$new_code]\n\n[freshcode =$cite_doi_start_code]\n\n> Error message generated by expand.php.");*/
          echo "Error - formatting doesn't match that expected of a cite doi template.  No edit made.  Output was:\n";
          print $new_code;
          return false; 
        }
      }
      if ($commit_edits) {
        global $jstor_redirect;
        if ($jstor_redirect && $jstor_redirect_target) {
          $page = "Template:Cite doi/" . wikititle_encode($jstor_redirect_target);
          write ("Template:Cite doi/" . wikititle_encode($jstor_redirect), "#REDIRECT [[$page]]"
            , $editInitiator . "Redirecting from JSTOR UID to official unique DOI, to avoid duplication");
          echo "\n * Redirected " . wikititle_encode($jstor_redirect) . " to $page. ";
        }
        if ($editing_cite_doi_template) {
          $p = $last_p; // temporary
          // Create any necessary redirects
          $pmid_page = "Template:Cite pmc/" . $p["pmc"][0];
          $pmid_page = "Template:Cite pmid/" . $p["pmid"][0];
          $doi_page = "Template:Cite doi/" . wikititle_encode($p["doi"][0]);
          $jstor_page = "Template:Cite doi/10.2307" . wikititle_encode("/" . $p["jstor"][0]);
          if (is("doi")) {
            $redirect_target = $doi_page;
          } else if (is("pmid")) {
            $redirect_target = $pmid_page;
          } else if (is("pmc")) {
            $redirect_target = $pmc_page;
          } else if (is("jstor")) {
            $redirect_target = $jstor_page;
          }
          // Check for re-directs and create if necessary
          if (is("pmc") && $redirect_target != $pmc_page && !getArticleId($pmc_page)) {
            write ($pmc_page, "#REDIRECT [[$redirect_target]]"
              , $editInitiator . "Redirecting to avoid duplication");
            $page = $redirect_target;
          }
          if (is("pmid") && $redirect_target != $pmid_page && !getArticleId($pmid_page)) {
            write ($pmid_page, "#REDIRECT [[$redirect_target]]"
              , $editInitiator . "Redirecting to avoid duplication");
            $page = $redirect_target;
          }
          if (is("jstor") && $redirect_target != $jstor_page && !getArticleId($jstor_page)) {
            write ($jstor_page, "#REDIRECT [[$redirect_target]]"
              , $editInitiator . "Redirecting from JSTOR UID to official unique DOI, to avoid duplication");
            $page = $redirect_target;
          }
          if (stripos($page, "plate:Cite jstor") && $p["jstor"][0]) {
            $page = $jstor_page;
          }
          $p = null; // re-reset
        }
      } else {
        echo $outputText;
        return $new_code;
      }

      //Unset smart edit summary parameters.  Some of these are globals modified by other functions.
      $pStart = null;
      $pEnd = null;
  } else {
    if (trim($original_code)=='') {
      echo "<b>Blank page.</b> Perhaps it's been deleted?";
      if (!$editing_cite_doi_template) {
        updateBacklog($page);
      }
      if ($html_output === -1) {
        ob_end_clean();
      }
      return false;
    } else {
      echo "<b>Error:</b> Blank page produced. This bug has been reported. Page content: $original_code";
      // mail ("MartinS+doibot@gmail.com", "DOI BOT ERROR", "Blank page produced.\n[Page = $page]\n[SmartSum = $auto_summary ]\n[\$citation = ". print_r($citation, 1) . "]\n[Request variables = ".print_r($_REQUEST, 1) . "]\n\nError message generated by expand.php.");
      exit;
    }
  }
  if ($html_output == -1) ob_end_clean();
  return $new_code;
}